<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bioconductor | English site</title>
    <link>/tags/bioconductor/</link>
      <atom:link href="/tags/bioconductor/index.xml" rel="self" type="application/rss+xml" />
    <description>bioconductor</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Maria Dermit, {2020}</copyright><lastBuildDate>Sat, 13 Feb 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu89765a528fbe3e89fbea23b995128687_292554_512x512_fill_lanczos_center_2.png</url>
      <title>bioconductor</title>
      <link>/tags/bioconductor/</link>
    </image>
    
    <item>
      <title>Overview of scRNAseq analysis</title>
      <link>/2021-02-13-scrnaseq/</link>
      <pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate>
      <guid>/2021-02-13-scrnaseq/</guid>
      <description>
&lt;script src=&#34;../../2021-02-13-scrnaseq/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-loading&#34;&gt;Data loading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#qc&#34;&gt;QC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#normalization&#34;&gt;Normalization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#variance-modellingfeature-selection&#34;&gt;Variance modelling/feature selection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dimensionality-reduction&#34;&gt;Dimensionality reduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clustering&#34;&gt;Clustering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interpretation&#34;&gt;Interpretation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;motivation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Exploration of the Common Framework for Analyzing Single-Cell RNA-seq data.&lt;/p&gt;
&lt;p&gt;The workflow of the 10X Single-Cell RNA-seq library prep for single-cell expression profiling looks like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medicine.uiowa.edu/humangenetics/genomics-sequencing-division/genome-sequencing/single-cell-expression-analysis-scrna-seq&#34;&gt;&lt;img src=&#34;10X.png&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dr. Eric Chow gives a fantastic overview of Droseq (&lt;a href=&#34;https://www.youtube.com/watch?v=k9VFNLLQP8c&amp;amp;t=1083s&#34;&gt;min 7:08&lt;/a&gt;).&lt;br /&gt;
&lt;br /&gt;
Once the data is generated the sequencial steps to handle scRNAseq are the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;scrnaseqframework.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The central object of the pipeline is &lt;code&gt;SingleCellExperiment&lt;/code&gt;, which looks like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://biocworkshops2019.bioconductor.org.s3-website-us-east-1.amazonaws.com/page/OSCABioc2019__OSCABioc2019/&#34;&gt;&lt;img src=&#34;SingleCellExperiment.png&#34; alt=&#34;SingleCellExperiment object&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;http://bioconductor.org/books/release/OSCA/&#34;&gt;OSCA book&lt;/a&gt; is an amazing resource to fully understand the math behind scRNAseq analysis workflow. It has 18 cases studies of scRNAseq.&lt;/p&gt;
&lt;p&gt;The main steps followed in scRNAseq are:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Data Loading&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;QC&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Normalization&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Variance modeling&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dimensionality reduction&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Clustering&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interpretation&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;data-loading&#34; class=&#34;section level1&#34; style=&#34;color: black&#34;&gt;
&lt;h1&gt;Data loading&lt;/h1&gt;
&lt;p&gt;Here, I am going to use an example of 10X Genomics data the counts matrix and associated metadata (cell barcodes, data path, etc.). This is based on &lt;a href=&#34;http://bioconductor.org/books/release/OSCA/unfiltered-human-pbmcs-10x-genomics.html&#34;&gt;Chapter 27 in OSCA book&lt;/a&gt;. The &lt;a href=&#34;https://bioconductor.org/packages/3.12/DropletTestFiles&#34;&gt;&lt;em&gt;DropletTestFiles&lt;/em&gt;&lt;/a&gt; package contains files that are the raw output of pipelines like 10X Genomics’ CellRanger software suite, that can be then imported via the &lt;a href=&#34;https://bioconductor.org/packages/3.12/DropletUtils&#34;&gt;&lt;em&gt;DropletUtils&lt;/em&gt;&lt;/a&gt; package’s &lt;code&gt;read10xCounts()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DropletTestFiles)
raw.path &amp;lt;- getTestFile(&amp;quot;tenx-2.1.0-pbmc4k/1.0.0/raw.tar.gz&amp;quot;)
out.path &amp;lt;- file.path(tempdir(), &amp;quot;pbmc4k&amp;quot;)
untar(raw.path, exdir=out.path)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(DropletUtils)
fname &amp;lt;- file.path(out.path, &amp;quot;raw_gene_bc_matrices/GRCh38&amp;quot;)
sce.pbmc &amp;lt;- read10xCounts(fname, col.names=TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to make sure that we convert the easy interpretable gene symbol to a standard identifier that is guaranteed to be unique and valid (e.g., Ensembl).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(scater)
rownames(sce.pbmc) &amp;lt;- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol)
library(EnsDb.Hsapiens.v86)
location &amp;lt;- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce.pbmc)$ID, 
    column=&amp;quot;SEQNAME&amp;quot;, keytype=&amp;quot;GENEID&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition to this, the &lt;a href=&#34;https://bioconductor.org/packages/release/data/experiment/vignettes/scRNAseq/inst/doc/scRNAseq.html&#34;&gt;scRNAseq package&lt;/a&gt; provides convenient access to several publicly available data sets in the form of &lt;code&gt;SingleCellExperiment&lt;/code&gt; object.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(scRNAseq)
out &amp;lt;- listDatasets()
dim(out)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 46  5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(out)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## DataFrame with 6 rows and 5 columns
##                Reference  Taxonomy                 Part    Number
##              &amp;lt;character&amp;gt; &amp;lt;integer&amp;gt;          &amp;lt;character&amp;gt; &amp;lt;integer&amp;gt;
## 1 @aztekin2019identifi..      8355                 tail     13199
## 2 @bach2017differentia..     10090        mammary gland     25806
## 3   @baron2016singlecell      9606             pancreas      8569
## 4   @baron2016singlecell     10090             pancreas      1886
## 5 @buettner2015computa..     10090 embryonic stem cells       288
## 6 @campbell2017molecular     10090                brain     21086
##                     Call
##              &amp;lt;character&amp;gt;
## 1      AztekinTailData()
## 2      BachMammaryData()
## 3 BaronPancreasData(&amp;#39;h..
## 4 BaronPancreasData(&amp;#39;m..
## 5      BuettnerESCData()
## 6    CampbellBrainData()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;qc&#34; class=&#34;section level1&#34; style=&#34;color:black&#34;&gt;
&lt;h1&gt;QC&lt;/h1&gt;
&lt;p&gt;An unique aspect of droplet-based data is that we have no prior knowledge about whether a particular library (i.e., cell barcode) corresponds to cell-containing or empty droplets. We use the &lt;code&gt;emptyDrops()&lt;/code&gt; function to test whether the expression profile for each cell barcode is significantly different from the ambient RNA pool. &lt;code&gt;emptyDrops()&lt;/code&gt; assumes that barcodes with low total UMI counts are empty droplets. &lt;code&gt;emptyDrops()&lt;/code&gt; uses Monte Carlo simulations to compute p-values for the multinomial sampling transcripts from the ambient pool.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(100) #seed forreproducible results, emptyDrops performas a simulation.
e.out &amp;lt;- emptyDrops(counts(sce.pbmc))
sce.pbmc &amp;lt;- sce.pbmc[,which(e.out$FDR &amp;lt;= 0.001)] #we exclude dropplets that have low UMI counts &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are the unfiltered, non-empty drops&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unfiltered &amp;lt;- sce.pbmc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each cell, we calculate these QC metrics using the &lt;code&gt;perCellQCMetrics()&lt;/code&gt; function from the &lt;a href=&#34;https://bioconductor.org/packages/3.12/scater&#34;&gt;&lt;em&gt;scater&lt;/em&gt;&lt;/a&gt; package. The &lt;code&gt;sum&lt;/code&gt; column contains the total count for each cell and the &lt;code&gt;detected&lt;/code&gt; column contains the number of detected genes. Mitochondrial counts are informative, because small mitochondrial percentages, large spike-in percentages and small library sizes are likely to be stripped nuclei, i.e., they have been so extensively damaged that they have lost all cytoplasmic content, therefore are low quality cells. Here we use a relaxed QC strategy and only remove cells with large mitochondrial proportions, using it as a proxy for cell damage. This reduces the risk of removing cell types with low RNA content, especially in a heterogeneous PBMC population with many different cell types.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stats &amp;lt;- perCellQCMetrics(sce.pbmc, subsets=list(Mito=which(location==&amp;quot;MT&amp;quot;)))
high.mito &amp;lt;- isOutlier(stats$subsets_Mito_percent, type=&amp;quot;higher&amp;quot;)
sce.pbmc &amp;lt;- sce.pbmc[,!high.mito]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(high.mito)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Mode   FALSE    TRUE 
## logical    3985     315&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;colData(unfiltered) &amp;lt;- cbind(colData(unfiltered), stats)
unfiltered$discard &amp;lt;- high.mito

gridExtra::grid.arrange(
    plotColData(unfiltered, y=&amp;quot;sum&amp;quot;, colour_by=&amp;quot;discard&amp;quot;) +
        scale_y_log10() + ggtitle(&amp;quot;Total count&amp;quot;),
    plotColData(unfiltered, y=&amp;quot;detected&amp;quot;, colour_by=&amp;quot;discard&amp;quot;) +
        scale_y_log10() + ggtitle(&amp;quot;Detected features&amp;quot;),
    plotColData(unfiltered, y=&amp;quot;subsets_Mito_percent&amp;quot;,
        colour_by=&amp;quot;discard&amp;quot;) + ggtitle(&amp;quot;Mito percent&amp;quot;),
    ncol=2
)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-unfiltered-pbmc-qc&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-unfiltered-pbmc-qc-1.png&#34; alt=&#34;Distribution of various QC metrics in the PBMC dataset after cell calling. Each point is a cell and is colored according to whether it was discarded by the mitochondrial filter.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Distribution of various QC metrics in the PBMC dataset after cell calling. Each point is a cell and is colored according to whether it was discarded by the mitochondrial filter.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plotColData(unfiltered, x=&amp;quot;sum&amp;quot;, y=&amp;quot;subsets_Mito_percent&amp;quot;,
    colour_by=&amp;quot;discard&amp;quot;) + scale_x_log10()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-unfiltered-pbmc-mito&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-unfiltered-pbmc-mito-1.png&#34; alt=&#34;Proportion of mitochondrial reads in each cell of the PBMC dataset compared to its total count.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Proportion of mitochondrial reads in each cell of the PBMC dataset compared to its total count.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;normalization&#34; class=&#34;section level1&#34; style=&#34;color:black&#34;&gt;
&lt;h1&gt;Normalization&lt;/h1&gt;
&lt;p&gt;There are a number of &lt;a href=&#34;http://bioconductor.org/books/release/OSCA/normalization.html&#34;&gt;normalization methods&lt;/a&gt;. We use a pre-clustering step with &lt;code&gt;quickCluster()&lt;/code&gt; where cells in each cluster are normalized separately and the size factors are rescaled to be comparable across clusters. This avoids the assumption that most genes are non-DE across the entire population - only a non-DE majority is required between pairs of clusters, which is a weaker assumption for highly heterogeneous populations. By default, &lt;code&gt;quickCluster()&lt;/code&gt; will use an approximate algorithm for PCA based on methods from the &lt;a href=&#34;https://cran.r-project.org/package=irlba&#34;&gt;&lt;em&gt;irlba&lt;/em&gt;&lt;/a&gt; package. The approximation relies on stochastic initialization so we need to set the random seed (via &lt;code&gt;set.seed()&lt;/code&gt;) for reproducibility. &lt;code&gt;computeSumFactors&lt;/code&gt; performs a scaling normalization of single-cell RNA-seq data by deconvolving size factors from cell pools. Once we have computed the size factors, we use the &lt;code&gt;logNormCounts()&lt;/code&gt; function from &lt;a href=&#34;https://bioconductor.org/packages/3.12/scater&#34;&gt;&lt;em&gt;scater&lt;/em&gt;&lt;/a&gt; to compute normalized expression values for each cell. This is done by dividing the count for each gene/spike-in transcript with the appropriate size factor for that cell. The function also log-transforms the normalized values, creating a new assay called &lt;code&gt;&#34;logcounts&#34;&lt;/code&gt;. (Technically, these are “log-transformed normalized expression values”, but that’s too much of a mouthful to fit into the assay name.) These log-values will be the basis of our downstream analyses.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(scran)
set.seed(1000)
clusters &amp;lt;- quickCluster(sce.pbmc)
sce.pbmc &amp;lt;- computeSumFactors(sce.pbmc, cluster=clusters)
sce.pbmc &amp;lt;- logNormCounts(sce.pbmc)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(sizeFactors(sce.pbmc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
##  0.00749  0.71207  0.87490  1.00000  1.09900 12.25412&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can plot The “library size factor” for each cell. As for bulk RNAseq, library
size normalization is the simplest strategy for performing scaling normalization.
However, library size normalization is usually sufficient in many applications where the aim is to identify clusters and the top markers that define each cluster.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(librarySizeFactors(sce.pbmc), sizeFactors(sce.pbmc), pch=16,
    xlab=&amp;quot;Library size factors&amp;quot;, ylab=&amp;quot;Deconvolution factors&amp;quot;, log=&amp;quot;xy&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-unfiltered-pbmc-norm&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-unfiltered-pbmc-norm-1.png&#34; alt=&#34;Relationship between the library size factors and the deconvolution size factors in the PBMC dataset.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: Relationship between the library size factors and the deconvolution size factors in the PBMC dataset.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;variance-modellingfeature-selection&#34; class=&#34;section level1&#34; style=&#34;color:black&#34;&gt;
&lt;h1&gt;Variance modelling/feature selection&lt;/h1&gt;
&lt;p&gt;Several methods are available to quantify the variation per gene and to select an appropriate set of &lt;strong&gt;highly variable genes (HVGs)&lt;/strong&gt;. UMI counts typically exhibit near-Poisson variation if we only consider technical noise from library preparation and sequencing. This can be used to construct a mean-variance trend in the log-counts with the &lt;code&gt;modelGeneVarByPoisson&lt;/code&gt; function. We can then select the top 10% of genes with the highest biological components.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1001)
dec.pbmc &amp;lt;- modelGeneVarByPoisson(sce.pbmc)
top.pbmc &amp;lt;- getTopHVGs(dec.pbmc, prop=0.1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(dec.pbmc$mean, dec.pbmc$total, pch=16, cex=0.5,
    xlab=&amp;quot;Mean of log-expression&amp;quot;, ylab=&amp;quot;Variance of log-expression&amp;quot;)
curfit &amp;lt;- metadata(dec.pbmc)
curve(curfit$trend(x), col=&amp;#39;dodgerblue&amp;#39;, add=TRUE, lwd=2)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-unfiltered-pbmc-var&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-unfiltered-pbmc-var-1.png&#34; alt=&#34;Per-gene variance as a function of the mean for the log-expression values in the PBMC dataset. Each point represents a gene (black) with the mean-variance trend (blue) fitted to simulated Poisson counts.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 4: Per-gene variance as a function of the mean for the log-expression values in the PBMC dataset. Each point represents a gene (black) with the mean-variance trend (blue) fitted to simulated Poisson counts.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;dimensionality-reduction&#34; class=&#34;section level1&#34; style=&#34;color:black&#34;&gt;
&lt;h1&gt;Dimensionality reduction&lt;/h1&gt;
&lt;p&gt;Now we want to compare cells based on the values of gene expression. We can use
&lt;code&gt;denoisePCA&lt;/code&gt; function, that “de-noises” log-expression data by removing principal components corresponding to technical noise.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(10000)
sce.pbmc &amp;lt;- denoisePCA(sce.pbmc, subset.row=top.pbmc, technical=dec.pbmc)
set.seed(100000)
sce.pbmc &amp;lt;- runTSNE(sce.pbmc, dimred=&amp;quot;PCA&amp;quot;) 
set.seed(1000000)
sce.pbmc &amp;lt;- runUMAP(sce.pbmc, dimred=&amp;quot;PCA&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We verify how many PCs were retained.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ncol(reducedDim(sce.pbmc, &amp;quot;PCA&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 9&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;clustering&#34; class=&#34;section level1&#34; style=&#34;color:black&#34;&gt;
&lt;h1&gt;Clustering&lt;/h1&gt;
&lt;p&gt;We can now create nearest-neighbor graphs with the &lt;code&gt;buildSNNGraph&lt;/code&gt; function and
&lt;code&gt;cluster_walktrap&lt;/code&gt; function. &lt;code&gt;cluster_walktrap&lt;/code&gt; will assign membership of densely connected subgraphs, also called “communities”.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;g &amp;lt;- buildSNNGraph(sce.pbmc, k=10, use.dimred = &amp;#39;PCA&amp;#39;)
clust &amp;lt;- igraph::cluster_walktrap(g)$membership
colLabels(sce.pbmc) &amp;lt;- factor(clust)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(colLabels(sce.pbmc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 
## 205 508 541  56 374 125  46 432 302 867  47 155 166  61  84  16&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plotTSNE(sce.pbmc, colour_by=&amp;quot;label&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-unfiltered-pbmc-tsne&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-unfiltered-pbmc-tsne-1.png&#34; alt=&#34;Obligatory $t$-SNE plot of the PBMC dataset, where each point represents a cell and is colored according to the assigned cluster.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 5: Obligatory &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-SNE plot of the PBMC dataset, where each point represents a cell and is colored according to the assigned cluster.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;interpretation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Interpretation&lt;/h1&gt;
&lt;p&gt;To interpret the clustering results, we need to identify the genes that drive separation between clusters. In the most obvious case, the marker genes for each cluster are a priori associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity. The same principle can be applied to discover more subtle differences between clusters (e.g., changes in activation or differentiation state) based on the behavior of genes in the affected pathways.
We perform pairwise t-tests between clusters for each gene using the &lt;code&gt;findMarkers&lt;/code&gt; function, which uses a Welch t-test to perform DE testing between clusters and returns a list of DataFrames containing ranked candidate markers for each cluster.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;markers &amp;lt;- findMarkers(sce.pbmc, pval.type=&amp;quot;some&amp;quot;, direction=&amp;quot;up&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s say that we want to examine the markers for cluster 8 in more detail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;marker.set &amp;lt;- markers[[&amp;quot;8&amp;quot;]]
as.data.frame(marker.set[1:30,1:3])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                     p.value           FDR summary.logFC
## CSTA          7.170624e-222 2.015964e-217     2.4178954
## MNDA          1.196631e-221 2.015964e-217     2.6614935
## FCN1          2.375980e-213 2.668543e-209     2.6380934
## S100A12       4.393470e-212 3.700839e-208     3.0808902
## VCAN          1.711043e-199 1.153038e-195     2.2603760
## TYMP          1.173532e-154 6.590164e-151     2.0237930
## AIF1          3.673649e-149 1.768285e-145     2.4603604
## LGALS2        4.004740e-137 1.686696e-133     1.8927606
## MS4A6A        5.639909e-134 2.111457e-130     1.5457061
## FGL2          2.044513e-124 6.888781e-121     1.3859366
## RP11-1143G9.4 6.891551e-122 2.110945e-118     2.8042347
## AP1S2         1.786019e-112 5.014842e-109     1.7703547
## CD14          1.195352e-110 3.098169e-107     1.4259764
## CFD           6.870490e-109 1.653531e-105     1.3560255
## GPX1          9.048825e-107 2.032607e-103     2.4013937
## TNFSF13B       3.920319e-95  8.255701e-92     1.1151275
## KLF4           3.309726e-94  6.559876e-91     1.2049050
## GRN            4.801206e-91  8.987324e-88     1.3814668
## NAMPT          2.489624e-90  4.415020e-87     1.1438687
## CLEC7A         7.736088e-88  1.303299e-84     1.0616120
## S100A8         3.124930e-84  5.013875e-81     4.8051993
## SERPINA1       1.580359e-82  2.420392e-79     1.3842689
## CD36           8.018347e-79  1.174653e-75     1.0538169
## MPEG1          8.481588e-79  1.190744e-75     0.9778095
## CD68           5.118714e-78  6.898798e-75     0.9481203
## CYBB           1.200516e-77  1.555776e-74     1.0300245
## S100A11        1.174556e-72  1.465759e-69     1.8962486
## RBP7           2.467027e-71  2.968714e-68     0.9666127
## BLVRB          3.762610e-71  4.371634e-68     0.9701168
## CD302          9.859086e-71  1.107307e-67     0.8792077&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The high expression of &lt;em&gt;MNDA&lt;/em&gt;, &lt;em&gt;CD14&lt;/em&gt; and &lt;em&gt;CD68&lt;/em&gt; suggests that cluster 8 contains monocytes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;marker.set &amp;lt;- markers[[&amp;quot;15&amp;quot;]]
as.data.frame(marker.set[1:30,1:3])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                p.value          FDR summary.logFC
## AIF1      6.912466e-82 2.329086e-77      3.678553
## FCGR3A    3.606603e-64 6.076045e-60      3.041108
## SERPINA1  6.149257e-64 6.906436e-60      2.375549
## FTL       2.857395e-63 2.406927e-59      2.061453
## LST1      4.161324e-62 2.804233e-58      1.892121
## COTL1     1.582271e-61 8.885507e-58      1.305713
## CTSS      3.143428e-55 1.513067e-51      1.880227
## S100A11   1.719244e-54 7.241024e-51      2.030715
## TYMP      4.395645e-50 1.645632e-46      2.101758
## MS4A7     7.348647e-48 2.476053e-44      2.173820
## NAP1L1    2.806622e-47 8.596939e-44      1.142910
## FTH1      5.856763e-47 1.644481e-43      1.188781
## CD68      2.661218e-46 6.897469e-43      2.048530
## STXBP2    5.783395e-45 1.391898e-41      2.075910
## SAT1      9.269854e-43 2.082256e-39      1.541614
## TYROBP    3.459416e-42 7.285097e-39      1.152396
## PSAP      1.582943e-40 3.137392e-37      1.403571
## CSTB      3.871723e-40 7.247436e-37      1.129131
## CFD       4.529809e-39 8.033020e-36      1.999696
## FKBP1A    5.042155e-39 8.494519e-36      1.301575
## CEBPB     6.875529e-39 1.103162e-35      1.683662
## LINC01272 7.357858e-38 1.126889e-34      1.840199
## FCER1G    2.802003e-37 4.104813e-34      1.301967
## SPI1      9.236815e-36 1.296772e-32      1.890047
## S100A4    4.102320e-35 5.528943e-32      4.356299
## NEAT1     5.928869e-33 7.683358e-30      1.358303
## IFITM3    6.875461e-33 8.580066e-30      1.871086
## LYZ       8.944290e-32 1.076317e-28      1.804654
## LRRC25    1.072482e-31 1.246077e-28      1.242115
## RNASET2   7.560048e-31 8.490942e-28      1.090212&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The high expression of &lt;em&gt;FCGR3A&lt;/em&gt; suggests that cluster 15 contains macrophagues.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Checking the cluster is what we wanted.
marker.set &amp;lt;- markers[[&amp;quot;8&amp;quot;]]
topset &amp;lt;- rownames(marker.set)[1:30]
stopifnot(all(c(&amp;quot;CD14&amp;quot;, &amp;quot;CD68&amp;quot;, &amp;quot;MNDA&amp;quot;) %in% topset))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plotExpression(sce.pbmc, features=c(&amp;quot;CD14&amp;quot;, &amp;quot;CD68&amp;quot;,
    &amp;quot;MNDA&amp;quot;, &amp;quot;FCGR3A&amp;quot;), x=&amp;quot;label&amp;quot;, colour_by=&amp;quot;label&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unref-mono-pbmc-markers&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-02-13-scrnaseq/index_files/figure-html/unref-mono-pbmc-markers-1.png&#34; alt=&#34;Distribution of expression values for monocyte and macrophage markers across clusters in the PBMC dataset.&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 6: Distribution of expression values for monocyte and macrophage markers across clusters in the PBMC dataset.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Word network of Bioconductor packages</title>
      <link>/2021-01-30-network-visualization-of-bioconductor-packages/</link>
      <pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/2021-01-30-network-visualization-of-bioconductor-packages/</guid>
      <description>
&lt;script src=&#34;../../2021-01-30-network-visualization-of-bioconductor-packages/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#statistics-of-bioconductor-downloads&#34;&gt;Statistics of Bioconductor downloads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#full-details-of-bioconductor-packages&#34;&gt;Full details of Bioconductor packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#word-network-of-bioconductor-packages&#34;&gt;Word network of Bioconductor packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusions&#34;&gt;Conclusions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(BiocPkgTools)
library(tidyverse)
library(tidytext)
library(widyr)
library(igraph)
library(ggraph)
library(lubridate)
library(emo)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;motivation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Bioconductor has a total of 5796 at the present day 2021-01-31. Therefore, navigating across Bioconductor packages can be a daunting experience. Luckily, &lt;a href=&#34;https://seandavi.github.io/BiocPkgTools/&#34;&gt;BiocPkgTools&lt;/a&gt; offers a rich ecosystem of metadata around Bioconductor packages 📜.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;statistics-of-bioconductor-downloads&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Statistics of Bioconductor downloads&lt;/h1&gt;
&lt;p&gt;We can get a tidy data.frame with download stats for all packages using the function &lt;code&gt;biocDownloadStats&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#  Getting a tidy tibble summarizing monthly download statistics 
bio_download_stats &amp;lt;- biocDownloadStats()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bio_download_stats %&amp;gt;% 
  head(13)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 13 x 7
##    Package  Year Month Nb_of_distinct_IPs Nb_of_downloads repo     Date      
##    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;              &amp;lt;int&amp;gt;           &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;date&amp;gt;    
##  1 ABarray  2021 Jan                   54             114 Software 2021-01-01
##  2 ABarray  2021 Feb                    0               0 Software 2021-02-01
##  3 ABarray  2021 Mar                    0               0 Software 2021-03-01
##  4 ABarray  2021 Apr                    0               0 Software 2021-04-01
##  5 ABarray  2021 May                    0               0 Software 2021-05-01
##  6 ABarray  2021 Jun                    0               0 Software 2021-06-01
##  7 ABarray  2021 Jul                    0               0 Software 2021-07-01
##  8 ABarray  2021 Aug                    0               0 Software 2021-08-01
##  9 ABarray  2021 Sep                    0               0 Software 2021-09-01
## 10 ABarray  2021 Oct                    0               0 Software 2021-10-01
## 11 ABarray  2021 Nov                    0               0 Software 2021-11-01
## 12 ABarray  2021 Dec                    0               0 Software 2021-12-01
## 13 ABarray  2021 all                   54             114 Software NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we see observations for all the months of the year are generated once that the year starts (download values for events in the future are filled up with &lt;em&gt;0&lt;/em&gt;). Also note that there is a summary statistic for month called &lt;code&gt;all&lt;/code&gt; embedded inside the tibble, and the &lt;code&gt;Date&lt;/code&gt; value for that observation is NA (this would makes group by date very convenient).&lt;/p&gt;
&lt;p&gt;This tibble contains information about packages that expands from 2009 to 2021. There are 3 categories of packages, with the total number of package per category as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bio_download_stats %&amp;gt;% 
  distinct(Package, repo) %&amp;gt;%
  count(repo) %&amp;gt;%
  knitr::kable()&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;repo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;n&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;AnnotationData&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2659&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;ExperimentData&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;821&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Software&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2316&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;full-details-of-bioconductor-packages&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Full details of Bioconductor packages&lt;/h1&gt;
&lt;p&gt;The complete information for the packages as described in the &lt;code&gt;DESCRIPTION&lt;/code&gt; file can be obtained with &lt;code&gt;biocPkgList&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bpi = biocPkgList()
colnames(bpi)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Package&amp;quot;               &amp;quot;Version&amp;quot;               &amp;quot;Depends&amp;quot;              
##  [4] &amp;quot;Suggests&amp;quot;              &amp;quot;License&amp;quot;               &amp;quot;MD5sum&amp;quot;               
##  [7] &amp;quot;NeedsCompilation&amp;quot;      &amp;quot;Title&amp;quot;                 &amp;quot;Description&amp;quot;          
## [10] &amp;quot;biocViews&amp;quot;             &amp;quot;Author&amp;quot;                &amp;quot;Maintainer&amp;quot;           
## [13] &amp;quot;git_url&amp;quot;               &amp;quot;git_branch&amp;quot;            &amp;quot;git_last_commit&amp;quot;      
## [16] &amp;quot;git_last_commit_date&amp;quot;  &amp;quot;Date/Publication&amp;quot;      &amp;quot;source.ver&amp;quot;           
## [19] &amp;quot;win.binary.ver&amp;quot;        &amp;quot;mac.binary.ver&amp;quot;        &amp;quot;vignettes&amp;quot;            
## [22] &amp;quot;vignetteTitles&amp;quot;        &amp;quot;hasREADME&amp;quot;             &amp;quot;hasNEWS&amp;quot;              
## [25] &amp;quot;hasINSTALL&amp;quot;            &amp;quot;hasLICENSE&amp;quot;            &amp;quot;Rfiles&amp;quot;               
## [28] &amp;quot;dependencyCount&amp;quot;       &amp;quot;Imports&amp;quot;               &amp;quot;Enhances&amp;quot;             
## [31] &amp;quot;dependsOnMe&amp;quot;           &amp;quot;VignetteBuilder&amp;quot;       &amp;quot;suggestsMe&amp;quot;           
## [34] &amp;quot;LinkingTo&amp;quot;             &amp;quot;Archs&amp;quot;                 &amp;quot;URL&amp;quot;                  
## [37] &amp;quot;SystemRequirements&amp;quot;    &amp;quot;BugReports&amp;quot;            &amp;quot;importsMe&amp;quot;            
## [40] &amp;quot;Video&amp;quot;                 &amp;quot;linksToMe&amp;quot;             &amp;quot;OS_type&amp;quot;              
## [43] &amp;quot;PackageStatus&amp;quot;         &amp;quot;License_restricts_use&amp;quot; &amp;quot;License_is_FOSS&amp;quot;      
## [46] &amp;quot;organism&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is lots of information in here. We could use this metadata information to understand the connections between packages.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;word-network-of-bioconductor-packages&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Word network of Bioconductor packages&lt;/h1&gt;
&lt;p&gt;The most informative variables about the packages are &lt;code&gt;Title&lt;/code&gt; and &lt;code&gt;Description&lt;/code&gt; so we can explore the connections between packages doing some &lt;strong&gt;text mining&lt;/strong&gt; using a &lt;a href=&#34;https://www.tidytextmining.com/index.html&#34;&gt;Tidytext&lt;/a&gt; approach.&lt;/p&gt;
&lt;p&gt;To prepare our dataset we need to initially tokenize the text. The Wikipedia definition for &lt;a href=&#34;https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization&#34;&gt;tokenization&lt;/a&gt; on lexical analysis is as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tokenization is the process of demarcating and possibly classifying sections of a string of input characters&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;sections&lt;/em&gt; can be words, sentence, ngram or chapter (for example if analysis a book). In this case we are gonna break down package Titles or Description into words using the function &lt;code&gt;unnest_tokens&lt;/code&gt;.
In addition, we can remove &lt;a href=&#34;https://en.wikipedia.org/wiki/Stop_word&#34;&gt;stop words&lt;/a&gt; (included in the Tidytext dataset).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bpi_title &amp;lt;- bpi %&amp;gt;% 
  dplyr::select(Package, Title) %&amp;gt;%
  unnest_tokens(word, Title) %&amp;gt;% 
  anti_join(stop_words)

bpi_description &amp;lt;- bpi %&amp;gt;%
  dplyr::select(Package, Description) %&amp;gt;%
  unnest_tokens(word, Description) %&amp;gt;%
  anti_join(stop_words)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the number of words from Title is 11932 and the number
of words from Description is 59370, so package Descriptions
contain on average 5 times the words of package Titles.&lt;/p&gt;
&lt;p&gt;We can have a look at how the tokenised titles for each package look like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bpi_title&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 11,932 x 2
##    Package word      
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;     
##  1 a4      automated 
##  2 a4      affymetrix
##  3 a4      array     
##  4 a4      analysis  
##  5 a4      umbrella  
##  6 a4      package   
##  7 a4Base  automated 
##  8 a4Base  affymetrix
##  9 a4Base  array     
## 10 a4Base  analysis  
## # … with 11,922 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Them, we can use &lt;code&gt;pairwise_count&lt;/code&gt; from the &lt;a href=&#34;https://cran.r-project.org/web/packages/widyr/vignettes/intro.html&#34;&gt;widyr&lt;/a&gt; package to count how many times each pair of words occurs together in the package Title. This function works as a mutate in that it takes the variables to compare and returns a tibble with the pairwise columns and an extra column called &lt;code&gt;n&lt;/code&gt; containing the number of words co-occurrences. I think this function is very sweet 🍯!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bpi_titlepairs &amp;lt;- bpi_title %&amp;gt;%
pairwise_count(Package, word, sort = TRUE, upper = FALSE)

bpi_desciptionpairs &amp;lt;- bpi_description %&amp;gt;%
pairwise_count(Package, word, sort = TRUE, upper = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This data is ready for visualization of network of co-occurring words in package Titles. We can use the &lt;code&gt;ggraph&lt;/code&gt; package for visualizing this network. We are going to represent just the top co-occurring words, or otherwise we get a very populated network which is impossible to read.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1234)
bpi_titlepairs %&amp;gt;%
  filter(n &amp;gt;= 6) %&amp;gt;%
  graph_from_data_frame() %&amp;gt;%
  ggraph(layout = &amp;quot;fr&amp;quot;) +
  geom_edge_link(aes(edge_alpha = n, edge_width = n), edge_colour = &amp;quot;purple&amp;quot;) +
  geom_node_point(size = 5) +
  geom_node_text(aes(label = name), repel = TRUE, 
                 point.padding = unit(0.2, &amp;quot;lines&amp;quot;)) +
  theme_void()+
  theme(legend.position=&amp;quot;none&amp;quot;)+
  labs(title = &amp;quot;  Number of word co-ocurrences in packages titles&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-10&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-01-30-network-visualization-of-bioconductor-packages/index_files/figure-html/unnamed-chunk-10-1.png&#34; alt=&#34;Word network in Bioconductor packages Titles&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Word network in Bioconductor packages Titles
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;We see some clear and logical clustering of packages in this network.For example, DESEq and DESeq2 packages cluster together, as one would expect since they DESeq2 is the successor of DESeq. There are other obvious connections such as MSstatsTMTPTM and MSstatsTMTP since the former has added functionality to analyse PTMs on TMT shotgun mass spectrometry-based proteomic experiments.
There is a big cluster on the bottom left corner with packages to analyse RNASeq and single cell RNASeq.&lt;/p&gt;
&lt;p&gt;What about the network build from words of the Description?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1234)
bpi_desciptionpairs %&amp;gt;%
  filter(n &amp;gt;= 15) %&amp;gt;%
  graph_from_data_frame() %&amp;gt;%
  ggraph(layout = &amp;quot;fr&amp;quot;) +
  geom_edge_link(aes(edge_alpha = n, edge_width = n), edge_colour = &amp;quot;orange&amp;quot;) +
  geom_node_point(size = 5) +
  geom_node_text(aes(label = name), repel = TRUE, 
                 point.padding = unit(0.2, &amp;quot;lines&amp;quot;)) +
  theme_void()+
  theme(legend.position=&amp;quot;none&amp;quot;)+
  labs(title = &amp;quot;Number of word co-ocurrences in packages Description&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-11&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-01-30-network-visualization-of-bioconductor-packages/index_files/figure-html/unnamed-chunk-11-1.png&#34; alt=&#34;Word network in Bioconductor packages Description&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Word network in Bioconductor packages Description
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;We see more connections here, and some of the relationships are still obvious (e.g HiCcompare and multiHiCcompare, anota and anota2seq, AnnotationHub and ExperimentHub). This network is richer, and one would have to dive a bit deeper to get a better sense of this network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;Text mining of Bioconductor packages metadata is a straight forward visual way to understand the relationships between packages. One could go beyond this and for example finding words that are
especially important across package Descriptions by calculating &lt;a href=&#34;https://www.tidytextmining.com/tfidf.html#tfidf&#34;&gt;tf-idf statistic&lt;/a&gt;. One could also set up a GitHub Action executed as a CRON job to get updates periodically. This could turn into a challenge for &lt;a href=&#34;https://kevinrue.github.io/BiocChallenges/index.html&#34;&gt;BiocChallenges&lt;/a&gt;. This post was inspired by &lt;a href=&#34;https://www.tidytextmining.com/nasa.html&#34;&gt;Chapter 8&lt;/a&gt; of the Tidytext book and &lt;a href=&#34;https://kevinrue.github.io/post/biocpkgtools/&#34;&gt;BiocRoulette&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Transfer learning for spatial proteomics</title>
      <link>/2021-01-20-transfer-learning-for-spatial-proteomics/</link>
      <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/2021-01-20-transfer-learning-for-spatial-proteomics/</guid>
      <description>
&lt;script src=&#34;../../2021-01-20-transfer-learning-for-spatial-proteomics/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getting-the-data&#34;&gt;Getting the data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quetting-auxiliary-annotation-biomart-query&#34;&gt;Quetting auxiliary annotation (Biomart Query)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nearest-neighbour-transfer-learning&#34;&gt;Nearest neighbour transfer learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusions&#34;&gt;Conclusions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# loading libraries
# clearing environment bc https://support.bioconductor.org/p/p132709/
rm(list = ls())
library(pRoloc)
library(pRolocdata)
library(BiocStyle)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Within the cell, the localization of a given protein is determined by its biological
function. Subcellular proteomics is the method to study protein sub-cellular
localization in a systematic manner. There are two complementary ways to analysis localized proteins:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;On one hand biochemical sub-cellular fractionation experiments allow empirical quantification of protein across sub-cellular and sub-organellar compartments. Proteins are allocated to a given subcellular niche
if the detected intensity is higher than a threshold. We can say that this type of data has high signal-to-noise ratio, but is available in limited amounts (&lt;em&gt;primary&lt;/em&gt; data).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;On the other hand, databases such as &lt;a href=&#34;http://geneontology.org/&#34;&gt;GO&lt;/a&gt; contain large amount of information about sub-cellular proteins localisation, but this is information is blended for a many biological systems. We can say that this type of data has high low signal-to-noise, but is available in large amounts (&lt;em&gt;auxiliary&lt;/em&gt; data).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So we want to know &lt;em&gt;how to optimally combine&lt;/em&gt; primary and auxiliary data.💹&lt;/p&gt;
&lt;p&gt;To do so, we need to weight both types of data. If we imagine a multivariate
distribution (like a &lt;a href=&#34;https://github.com/TommyJones/tidylda&#34;&gt;Dirichlet distribution&lt;/a&gt;) were all the components take values between (0,1) and all values sum up to one, we can imagine that a weight of 1 indicates that the final annotation rely exclusively on the experimental data and ignore completely the auxiliary data and a weight of 0 represents the opposite situation, where the primary data is ignored and only the auxiliary data is considered.&lt;/p&gt;
&lt;p&gt;We could use a &lt;em&gt;transfer learning&lt;/em&gt; algorithm to efficiently complement the primary data with auxiliary data without compromising the integrity of the former. This is implemented in the &lt;code&gt;pRoloc&lt;/code&gt; package and it was published by &lt;a href=&#34;https://lgatto.github.io/pRoloc/reference/knntlClassification.html&#34;&gt;Breckels et al&lt;/a&gt; and expanded by
&lt;a href=&#34;https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1006516&#34;&gt;Crook et al&lt;/a&gt; using a Bayesian approach. In this post I will step-by-step walk through KNN transfer learning.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;getting-the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Getting the data&lt;/h1&gt;
&lt;p&gt;We start with &lt;code&gt;HEK293T2011&lt;/code&gt; proteomics data available in the &lt;em&gt;&lt;a href=&#34;https://bioconductor.org/packages/3.10/pRolocdata&#34;&gt;pRolocdata&lt;/a&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(HEK293T2011)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class of (HEK293T2011) isMSnSet instance, an efficient and established to &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/html/MSnbase.html&#34;&gt;store and handle MS data and metainformation efficiently&lt;/a&gt;. I am not going to discuss much about this class of objects since the field is moving towards other types of data storage such as &lt;a href=&#34;https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html&#34;&gt;SummarizedExperiment objects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can also get an overview experimental data and query how many proteins across how many conditions were quantified.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(exprs(HEK293T2011),2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             X113      X114       X115      X116      X117       X118       X119
## O00767 0.1360547 0.1495961 0.10623931 0.1465050 0.2773137 0.14294025 0.03796970
## P51648 0.1914456 0.2052463 0.05661169 0.1651138 0.2366302 0.09964387 0.01803788
##               X121
## O00767 0.003381233
## P51648 0.027270640&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(exprs(HEK293T2011))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1371    8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is important to know is that 1371 proteins were quantified across eight iTRAQ 8-plex labelled fractions (
one could know a bit more about the experiment with &lt;code&gt;?HEK293T2011&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Next thing we can do is see how well these organelles have been resolved in the experiment using a PCA plot&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot2D(HEK293T2011)
addLegend(HEK293T2011, where = &amp;quot;topright&amp;quot;, cex = 0.6)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-4&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;../../2021-01-20-transfer-learning-for-spatial-proteomics/index_files/figure-html/unnamed-chunk-4-1.png&#34; alt=&#34;PCA plot of `HEK293T2011 subcellular proteomics dataset`&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: PCA plot of &lt;code&gt;HEK293T2011 subcellular proteomics dataset&lt;/code&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;We see that some organelles such as cytosol and cytosol/nucleus are well resolved - and so they will get a high weigh- while others such as the Golgi or the ER are less so - so they will get a low weight.
There are some proteins that do not get annotation because the resolution of the experiment did not allow so.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;quetting-auxiliary-annotation-biomart-query&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Quetting auxiliary annotation (Biomart Query)&lt;/h1&gt;
&lt;p&gt;Next thing we can do is get auxiliary data. We can do so by querying &lt;em&gt;&lt;a href=&#34;https://bioconductor.org/packages/3.10/biomaRt&#34;&gt;biomaRt&lt;/a&gt;&lt;/em&gt; and storing the annotation as an &lt;code&gt;AnnotationParams&lt;/code&gt; object. Again, this is part of the &lt;em&gt;&lt;a href=&#34;https://bioconductor.org/packages/3.10/pRoloc&#34;&gt;pRoloc&lt;/a&gt;&lt;/em&gt; package, and it has been created for efficient data handling.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ap &amp;lt;- setAnnotationParams(inputs =
                              c(&amp;quot;Human genes&amp;quot;,
                                &amp;quot;UniProtKB/Swiss-Prot ID&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Connecting to Biomart...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can access this instance with&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;getAnnotationParams()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Object of class &amp;quot;AnnotationParams&amp;quot;
##  Using the &amp;#39;ENSEMBL_MART_ENSEMBL&amp;#39; BioMart database
##  Using the &amp;#39;hsapiens_gene_ensembl&amp;#39; dataset
##  Using &amp;#39;uniprotswissprot&amp;#39; as filter
##  Created on Tue Jan 26 15:47:22 2021&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can annotate our innitial &lt;code&gt;HEK293T2011&lt;/code&gt; data by creating a new &lt;code&gt;MSnSet&lt;/code&gt; instance populated with a GO term as a binary matrix (so the auxiliary data with information about 889 cellular compartment GO terms has been added).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;HEK293T2011goset  &amp;lt;- makeGoSet(HEK293T2011)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;nearest-neighbour-transfer-learning&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Nearest neighbour transfer learning&lt;/h1&gt;
&lt;div id=&#34;deciding-the-weight&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Deciding the weight&lt;/h2&gt;
&lt;p&gt;We could define more or less weight values between 0 and 1 depending on how granular we want to be with
our search (more weight will give finer-grained integration).For example for 3 classes, 3 weights will generate:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gtools::permutations(length(seq(0, 1, 0.5)), 3, seq(0, 1, 0.5), repeats.allowed = TRUE) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3]
##  [1,]  0.0  0.0  0.0
##  [2,]  0.0  0.0  0.5
##  [3,]  0.0  0.0  1.0
##  [4,]  0.0  0.5  0.0
##  [5,]  0.0  0.5  0.5
##  [6,]  0.0  0.5  1.0
##  [7,]  0.0  1.0  0.0
##  [8,]  0.0  1.0  0.5
##  [9,]  0.0  1.0  1.0
## [10,]  0.5  0.0  0.0
## [11,]  0.5  0.0  0.5
## [12,]  0.5  0.0  1.0
## [13,]  0.5  0.5  0.0
## [14,]  0.5  0.5  0.5
## [15,]  0.5  0.5  1.0
## [16,]  0.5  1.0  0.0
## [17,]  0.5  1.0  0.5
## [18,]  0.5  1.0  1.0
## [19,]  1.0  0.0  0.0
## [20,]  1.0  0.0  0.5
## [21,]  1.0  0.0  1.0
## [22,]  1.0  0.5  0.0
## [23,]  1.0  0.5  0.5
## [24,]  1.0  0.5  1.0
## [25,]  1.0  1.0  0.0
## [26,]  1.0  1.0  0.5
## [27,]  1.0  1.0  1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we sayed before, HEK293T2011goset experiment has 10 subcellular compartments, and so the total combinations for 10 classes, 4 weights will be:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;th &amp;lt;- gtools::permutations(length(seq(0, 1, length.out = 4)), 10, seq(0, 1, length.out = 4), repeats.allowed = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Total combination of weights for HEK293T2011goset experiment will be 1048576.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://bioconductor.org/packages/3.10/pRoloc&#34;&gt;pRoloc&lt;/a&gt;&lt;/em&gt; package comes with a convenient function &lt;code&gt;thetas&lt;/code&gt; to produce such a weight matrix (because we need a theta for each of the training feature).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## marker classes for HEK293T2011
m &amp;lt;- unique(fData(HEK293T2011)$markers.tl)
m &amp;lt;- m[m != &amp;quot;unknown&amp;quot;]
th &amp;lt;- thetas(length(m), length.out=4)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;optimizing-weigth&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Optimizing weigth&lt;/h2&gt;
&lt;p&gt;We can do a grid search to determine which is the best &lt;code&gt;th&lt;/code&gt;, with the &lt;code&gt;knntlOptimisation&lt;/code&gt; function of the &lt;em&gt;&lt;a href=&#34;https://bioconductor.org/packages/3.10/pRoloc&#34;&gt;pRoloc&lt;/a&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;topt &amp;lt;- knntlOptimisation(HEK293T2011, HEK293T2011goset,
                          th = th,
                          k = c(3, 3),
                          fcol = &amp;quot;markers.tl&amp;quot;,
                          times = 50, 
                          method = &amp;quot;Breckels&amp;quot; )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the sake of time, we can reduce our initial data, as it will take a long time to do this grid search (even if &lt;code&gt;knntlOptimisation&lt;/code&gt; uses parallelisation by default).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(2021)
i &amp;lt;- sample(nrow(th), 50)
topt &amp;lt;- knntlOptimisation(HEK293T2011, HEK293T2011goset,
                          th = th[i, ],
                          k = c(3, 3),
                          fcol = &amp;quot;markers.tl&amp;quot;,
                          times = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The optimisation is performed on the labelled marker examples only. &lt;code&gt;topt&lt;/code&gt; result stores all the result from the optimisation step, and in particular the observed theta weights, which can be directly plotted as shown on the bubble plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(topt)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/lgatto/pRoloc/master/vignettes/Figures/bubble-andy.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Result stocores for the optimisation step. Note that this figure is the result using extensive optimisation on the whole HEK293T2011 dataset and auxiliary HEK293T2011goset dataset, not only with only a random subset of 50 candidate weights.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;We see that the cytosol and cytosol/nucleus and ER are predominantly scored with high heights, consistent with high reliability of the primary data. Golgi, PM and the 40S ribosomal clusters are scored with smaller scores, indicating a substantial benefit of the auxiliary data.&lt;/p&gt;
&lt;p&gt;The best grid search parameters can be accessed with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;getParams(topt)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the data &lt;code&gt;HEK293T2011&lt;/code&gt; &lt;em&gt;gets annotated&lt;/em&gt; with the best parameters at the knntlOptimisation
step. We can get the best weights with:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bw &amp;lt;- experimentData(HEK293T2011)@other$knntl$thetas&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;performing-transfer-learning&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Performing transfer learning&lt;/h2&gt;
&lt;p&gt;To apply the best weights and learn from the auxiliary data to classify the unlabelled proteins into sub-cellular niches (present in &lt;code&gt;markers.tl&lt;/code&gt; column), we can pass the primary and auxiliary data sets, best weights, best k’s and the metadata feature data taht contains the markers definitions to the &lt;code&gt;knntlClassification&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;HEK293T2011 &amp;lt;- knntlClassification(HEK293T2011, HEK293T2011goset,
                                bestTheta = bw,
                                k = c(3, 3),
                                fcol = &amp;quot;markers.tl&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this step, annotation predictors scores and parameters get added into the MSnSet data. We can access the predicted localization conveniently using the &lt;code&gt;getPredictions&lt;/code&gt; assessor.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;HEK293T2011 &amp;lt;- getPredictions(HEK293T2011, fcol = &amp;quot;knntl&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;plotting-the-results&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Plotting the results&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# These functions allow to get/set the colours/points to plot organelle features 
setStockcol(paste0(getStockcol(), &amp;quot;80&amp;quot;))
#this defines the point size
ptsze &amp;lt;- exp(fData(HEK293T2011)$knntl.scores) - 1
plot2D(HEK293T2011, fcol = &amp;quot;knntl&amp;quot;, cex = ptsze)
setStockcol(NULL)
addLegend(HEK293T2011, where = &amp;quot;topright&amp;quot;,
          fcol = &amp;quot;markers.tl&amp;quot;,
          bty = &amp;quot;n&amp;quot;, cex = .7)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;TL_PCA.png&#34; alt=&#34;&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;PCA plot of &lt;code&gt;HEK293T2011&lt;/code&gt; after transfer learning classification. The size of the points is proportional to the classification scores.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;A &lt;em&gt;weighted k-nearest neighbour transfer learning&lt;/em&gt; algorithm can be very useful to predict of protein
sub-cellular localisation using quantitative proteomics data as primary data source and Gene Ontology-derived binary data as auxiliary data source.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
